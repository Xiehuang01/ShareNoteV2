***
# v-model的底层原理
官方文档：
https://cn.vuejs.org/tutorial/#step-5
b站：
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=57
![[Pasted image 20251018150256.png]]
	$event的作用是拿到输入框事件的形参
![[Pasted image 20251018150801.png]]


# computed
https://cn.vuejs.org/tutorial/#step-8

| 情况   | methods                  | computed            |
| ---- | ------------------------ | ------------------- |
| 模板渲染 | 每次都会调用方法，不管依赖是否变         | 只有依赖的数据变化时才重新计算     |
| 数据变化 | 任何响应式数据变化，模板会检查依赖并更新 DOM | 只重新计算依赖变化的 computed |


# 生命周期与模版
https://cn.vuejs.org/tutorial/#step-9


# Vue-for and key
[018-指令-v-for的key_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=18)



# v-bind管理class
## 点击导航栏切换
[025-v-bind操作class_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=25)
![[Pasted image 20251014161959.png]]
![[Pasted image 20251014162048.png]]

## 进度条
[025-v-bind操作class_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=25)
![[Pasted image 20251014162617.png]]![[Pasted image 20251014162632.png]]


# v-model应用于其它的表单元素
[026-v-model应用于其他表单元素_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=26)
![[Pasted image 20251014165927.png]]
![[Pasted image 20251014170113.png]]
**如果以后要提交form的元素那么只用提交VueApp里面的data就好了(用this)**


# JavaScript补充
## 什么是回调函数？
https://www.bilibili.com/video/BV1NA4m1A7qr/?spm_id_from=333.337.search-card.all.click&vd_source=81f6abdfad38ec206b0ce368cd574c90

## array中reduce的用法
```JavaScript
const nums = [1, 2, 3, 4];
const result = nums.reduce((acc, cur) => acc + cur, 0);
console.log(result); // 输出 10
```
**过程：**

| 步骤  | acc（累计器） | cur（当前值） | 返回值 |
| --- | -------- | -------- | --- |
| 第1步 | 0(初始值)   | 1        | 1   |
| 第2步 | 1        | 2        | 3   |
| 第3步 | 3        | 3        | 6   |
| 第4步 | 6        | 4        | 10  |
 
 **如果没有这个 0 呢？**
看看这段：
```JavaScript
	const result = [1, 2, 3, 4].reduce((acc, cur) => acc + cur);
```

这时：
- JS 会自动把第一个元素 `1` 当作初始值；
- 从第二个元素 `2` 开始计算。
**所以过程变成：**

| 步骤  | acc | cur | 结果  |
| --- | --- | --- | --- |
| 第1步 | 1   | 2   | 3   |
| 第2步 | 3   | 3   | 6   |
| 第3步 | 6   | 4   | 10  |

## array中find的用法
```JavaScript
// 根据id找到item--用find在array中找到满足条件的元素
const fruit = this.fruitList.find(item => id === item.id);
fruit.num++;
```

## array中every的用法
```JavaScript
//当item全部满足条件整一个返回--true
return this.fruitList.every(item => item.isChecked === true);
// 或者写成
return this.fruitList.every(item => item.isChecked);
```

## array中map的用法
**map方法会遍历数组并且映射出来一个新的数组**
```JavaScript
data: this.list.map(item => ({value: item.id, name: item.name}))
```
	({value: item.id, name: item.name})之所以要加()是因为如果不加()，箭头函数会将{}识别成代码块

## array中join("")的用法
**用join("")中的符号进行拼接**
```JavaScript
array=["1","2","3"];
array.join(",");
```
	这时array.join(",");的输出结果是1,2,3

## array中filter的用法
```JavaScript
array=["1","1","3"];
arrray = array.filter(item =>item != 3);
```
	这时array的输出结果是1,1

## for-in
```JavaScript
array=["1","1","3"];
arrray = array.filter(item =>item != 3);
```

## forEach
```JavaScript
array=["1","1","3"];
arrray = array.filter(item =>item != 3);
```

## for-of
```JavaScript
array=["1","1","3"];
arrray = array.filter(item =>item != 3);
```

## 怎么保留两位小数？
```JavaScript
	let num = (123.123).toFixed(2);
```

## 数组元素的添加和删除
```JavaScript
	unshift--在头部添加元素 push--在尾部添加元素
	shift--删除头部元素 pop--删除尾部元素
```

## 怎么是实现本地化存储localStorage
```JavaScript
// 存储数据--代码转换为JSON格式
localStorage.setItem("list", JSON.stringify(newValue));
// 获得数据--从JSON格式转化为代码
JSON.parse(localStorage.getItem("list"))
```


# VSCode设置和插件
## Vue高亮插件

![[Pasted image 20251016172537.png]]

## Vue<>补全设置
![[Pasted image 20251016172633.png]]


# 计算属性
**基于现有的数据，计算出来新的属性，依赖的数据变化，自动重新计算**
**【注意：】 主要虽然很想函数，但是他是属性，所以引用时不需要()，记得{}里面要return**
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=27
![[Pasted image 20251014173820.png]]
![[Pasted image 20251014173842.png]]
![[Pasted image 20251014173548.png]]

## computed与methods的区别？
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=28
## computed
![[Pasted image 20251014174546.png]]
![[Pasted image 20251014174632.png]]
## methods
![[Pasted image 20251014174818.png]]
![[Pasted image 20251014174826.png]]
## 总结
![[Pasted image 20251014174523.png]]

## 计算属性完整写法
**既然说计算属性是一个属性，最终是return回来的值，那么我们外部函数怎么修改这个值呢？**
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=29
![[Pasted image 20251014175953.png]]

**我们发现显然直接修改是不行的，所以要用get、set完善compute的写法**
![[Pasted image 20251014175135.png]]
![[Pasted image 20251014180529.png]]
![[Pasted image 20251014180539.png]]


# watch监视器
## watch的简单写法
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=31
![[Pasted image 20251014191312.png]]
![[Pasted image 20251014192405.png]]
![[Pasted image 20251014192451.png]]
![[Pasted image 20251014192830.png]]
![[Pasted image 20251014192657.png]]

## watch防抖
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=32
![[Pasted image 20251014210745.png]]
![[Pasted image 20251014210808.png]]

## watch的完整写法
**对data中对象的所有属性进行监视，watch中的监视器也要写成对象(完整写法)**
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=33
![[Pasted image 20251014211136.png]]
![[Pasted image 20251014212953.png]]![[Pasted image 20251014213035.png]]

**但是问题是如果words有默认值不会执行翻译：**
![[Pasted image 20251014213723.png]]

**所以要在watch的监视器中加上immediate:true表示立刻执行**
![[Pasted image 20251014213925.png]]

## 总结
![[Pasted image 20251014214122.png]]


# 生命周期
**用于在某个阶段，执行某些代码，比如一进入界面调用接口获取数据，渲染界面**
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=36
![[Pasted image 20251015163149.png]]

## 生命周期钩子（生命周期函数）
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=36
![[Pasted image 20251015163510.png]]

**created、mounted、updated、destroyed**
![[Pasted image 20251015163711.png]]
## beforeCreate和created、beforeMount和mounted
![[Pasted image 20251015170201.png]]
![[Pasted image 20251015170214.png]]

## beforeUpdate和updated、beforeDestroy和destroyed
![[Pasted image 20251015170904.png]]
**销毁阶段一般是关闭浏览器的时候才执行，所以这里Vue提供了Vue对象名.$destory()来销毁实例**
**beforeDestroy一般用于销毁一些Vue以外的资源占用，例如定时器，延时器等**
![[Pasted image 20251015170923.png]]

## created应用
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=37
![[Pasted image 20251015171522.png]]
![[Pasted image 20251015200117.png]]
![[Pasted image 20251015192916.png]]
![[Pasted image 20251015192946.png]]

## mounted实践--获得输入框焦点
![[Pasted image 20251015200617.png]]
![[Pasted image 20251015200633.png]]


# 工程化开发&脚手架 Vue CLI
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=40
![[Pasted image 20251016113059.png]]
![[Pasted image 20251016113207.png]]
![[Pasted image 20251016114528.png]]

https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=41
## 脚手架--index.html
![[Pasted image 20251016145046.png]]

## 脚手架--main.js
![[Pasted image 20251016144928.png]]
**el: 与.$mount('#app')一致**
![[Pasted image 20251016150002.png]]
**基于App.vue(根组件)去渲染index.html页面**

## 原理
![[Pasted image 20251016152734.png]]**yarn serve或者npm run serve 启动 --> 启动main.js(将App.vue的Vue模板语法动态渲染到index.html的App容器当中，从而渲染出界面)**

## 组件化开发&根组件App.vue
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=42
![[Pasted image 20251016153745.png]]
![[Pasted image 20251016153934.png]]
![[Pasted image 20251016154407.png]]
![[Pasted image 20251016154901.png]]

![[Pasted image 20251016160721.png]]
![[Pasted image 20251016164347.png]]

# 普通组件的注册使用
![[Pasted image 20251016170622.png]]

## 普通组件--局部注册
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=43
![[Pasted image 20251016171315.png]]
![[Pasted image 20251016170820.png]]
**在组件App.vue中使用普通组件**
![[Pasted image 20251016172047.png]]


### 实践--显示
**在根目录上显示**
![[Pasted image 20251016204021.png]]
![[Pasted image 20251016204126.png]]
**局部注册--创建组件**
![[Pasted image 20251016204334.png]]
![[Pasted image 20251016204744.png]]
**将component的HmHeader.vue导入到App.vue中**
	引入HmHeader.vue，在components中引用
![[Pasted image 20251016205022.png]]
![[Pasted image 20251016205709.png]]
**同理：**
![[Pasted image 20251016205729.png]]
![[Pasted image 20251016205738.png]]
![[Pasted image 20251016210515.png]]


### 总结
![[Pasted image 20251016173008.png]]

## 普通组件--全局注册
![[Pasted image 20251016210003.png]]

### 实践--在HmHeader、HmMain、HmFooter中使用全局注册的组件
**定义全局注册的组件**
![[Pasted image 20251016212437.png]]
**导入全局注册的组件-->main.js**
![[Pasted image 20251016210536.png]]
**使用全局注册的组件--在其它组件中**
![[Pasted image 20251016212629.png]]

### 总结
![[Pasted image 20251016212842.png]]


# scoped样式冲突
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=48
![[Pasted image 20251017115509.png]]
![[Pasted image 20251017115851.png]]
## 样式冲突的情况--BaseOne.vue的div样式同时作用了其他两个组件(包括根组件)的div
**默认情况下style中直接定义的样式是全局样式**
![[Pasted image 20251017140852.png]]

## 解决样式冲突--使用局部样式：给style加上scoped属性
![[Pasted image 20251017141238.png]]

## scoped原理
![[Pasted image 20251017141601.png]]

## 总结
![[Pasted image 20251017141841.png]]


# data是一个函数
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=49
```JavaScript
data (){
	return {
		count: 100;
	}
}
```
![[Pasted image 20251017142051.png]]
![[Pasted image 20251017142809.png]]
![[Pasted image 20251017143356.png]]


# 组件通信
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=50
![[Pasted image 20251017144052.png]]
![[Pasted image 20251017144316.png]]
![[Pasted image 20251017144423.png]]

## 父子通信
- props：父 --> 子
- $emit：子 --> 父
![[Pasted image 20251017144710.png]]
### props：父-->子
![[Pasted image 20251017144949.png]]
![[Pasted image 20251017150800.png]]

### $emit：子-->父
![[Pasted image 20251017151317.png]]
	先在子中将自定义事件，和要传的参数通过$emit传送到父中
	父再通过事件触发父的自定义函数，自定义函数的形参就是接收子$emit中传过来的参数

### 总结
![[Pasted image 20251017153246.png]]


## 父子通信--什么是props？
https://www.bilibili.com/video/BV1HV4y1a7n4/?spm_id_from=333.1391.0.0&p=51&vd_source=81f6abdfad38ec206b0ce368cd574c90
![[Pasted image 20251017201622.png]]


### props校验
https://www.bilibili.com/video/BV1HV4y1a7n4/?spm_id_from=333.1391.0.0&p=51&vd_source=81f6abdfad38ec206b0ce368cd574c90
### 类型校验
![[Pasted image 20251017202631.png]]
![[Pasted image 20251017215107.png]]
![[Pasted image 20251017215131.png]]

### 非空校验、默认值、自定义校验
![[Pasted image 20251017215232.png]]
#### 非空校验--required
![[Pasted image 20251017220054.png]]
![[Pasted image 20251017220205.png]]
#### 默认值--default
![[Pasted image 20251017220243.png]]
![[Pasted image 20251017220300.png]]
![[Pasted image 20251017220309.png]]
**默认值会被覆盖**
![[Pasted image 20251017220446.png]]
![[Pasted image 20251017220506.png]]

#### 自定义校验--validator
![[Pasted image 20251017221118.png]]
![[Pasted image 20251017221159.png]]
![[Pasted image 20251017221209.png]]


### data和props的区别--props传入值”修改“
**data的值是组件自己的数据，所以可以对组件自己data的数据随意修改**
**props传入的值是单项数据流，是不能直接修改的，要通过$emit来间接修改**
![[Pasted image 20251017221632.png]]
**怎么”修改“呢？**
![[Pasted image 20251017223644.png]]![[Pasted image 20251017223712.png]]
![[Pasted image 20251017223751.png]]


## 非父子通信

### event bus--事件总线
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=55
![[Pasted image 20251018140356.png]]
#### 1.创建都能访问到的事件总线--.js文件
![[Pasted image 20251018141945.png]]
#### 2.在接收方进行监听，在加载完响应式数据后created阶段就开始监听--Bus.$on
![[Pasted image 20251018142505.png]]

#### 3.发送方--Bus.$emit
![[Pasted image 20251018143259.png]]

#### 4.总体逻辑
![[Pasted image 20251018141732.png]]

### 跨层级共享数据--provide&inject
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=56
![[Pasted image 20251018143753.png]]
#### 传送的方式
![[Pasted image 20251018144327.png]]

#### 传送类型的区别--简单类型和复杂类型例如对象
![[Pasted image 20251018144500.png]]
##### 简单类型--响应式
![[Pasted image 20251018144656.png]]

##### 复杂类型--非响应式
![[Pasted image 20251018144809.png]]

## v-model应用于组件
### 表单类组件封装
![[Pasted image 20251018155220.png]]
#### 什么时候用表单类组件封装--什么情况下不能用v-model?
![[Pasted image 20251018155850.png]]

#### 怎么拆解v-model用于表单类组件封装？
**父传子--传入值：**
![[Pasted image 20251018160317.png]]
![[Pasted image 20251018160333.png]]

**子传父--修改值(反向绑定)：**
![[Pasted image 20251018161920.png]]![[Pasted image 20251018162053.png]]

### v-model简化
![[Pasted image 20251018162448.png]]**父组件中，将:值和@事件改为v-model**
![[Pasted image 20251018163659.png]]
- 在父组件：
    `<BaseSelect v-model="selectId" />
    等价于：
    `<BaseSelect :value="selectId" @input="selectId = $event" />`
    所以子组件中
- **默认传送到子组件的prop名叫** `value`
- **默认接受子组件的事件名叫** `input`

**子组件中，将:cityId改为父组件v-model传送过来的:value，对于的props也要更改；发送到父组件的事件也改为对应的input**
![[Pasted image 20251018164221.png]]

**总结：**
![[Pasted image 20251018164348.png]]

## .sync修饰符
因为v-model来实现不同组件的双向绑定**必须**要求子组件的传入的值是value
而.sync可以用来自定义修饰符
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=58
![[Pasted image 20251018165019.png]]

**数据双向绑传送逻辑：**
![[Pasted image 20251018172940.png]]

## ref和$refs
### 用ref和$refs来获取dom元素
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=59
![[Pasted image 20251018174026.png]]
**安装echarts**
```npm
	npm install echarts --save
```

**当遇见相同class名字的div时：**
![[Pasted image 20251018175439.png]]
![[Pasted image 20251018175547.png]]

**使用ref和$refs来获取dom元素**
![[Pasted image 20251018175913.png]]
![[Pasted image 20251018175929.png]]

### 用ref和$refs来获取组件实例
![[Pasted image 20251018181457.png]]
![[Pasted image 20251018181644.png]]
![[Pasted image 20251018181802.png]]
![[Pasted image 20251018181847.png]]

## Vue异步更新、$nextTick
### Vue异步更新是什么？
![[Pasted image 20251019120359.png]]
![[Pasted image 20251019120943.png]]


### 使用$nextTick来解决Vue异步更新所出现的问题
![[Pasted image 20251019121236.png]]
![[Pasted image 20251019121723.png]]
**同理也可以用setTimeout来处理这个问题，但是不精准**

### 总结
![[Pasted image 20251019121917.png]]


# 自定义指令
## 基础语法
https://www.bilibili.com/video/BV1HV4y1a7n4/?spm_id_from=333.1391.0.0&p=62&vd_source=81f6abdfad38ec206b0ce368cd574c90
![[Pasted image 20251019140544.png]]
### 全局注册
```JavaScript
	Vue.directive("指令名", {
		inserted(el){
			el.focus();
		}
	})
```
![[Pasted image 20251019140128.png]]
![[Pasted image 20251019135911.png]]

### 局部注册
```JavaScript
	directives:{
		"指令名":{
			inserted(el){
				el.focus();
			}
		}
	}
```
![[Pasted image 20251019140213.png]]
![[Pasted image 20251019140411.png]]


## 指令的值
![[Pasted image 20251019141503.png]]
![[Pasted image 20251019141927.png]]
**但是现在现在binding.value不是响应式的--所以要用update


注意：inserted、update这些都是自定义指令自己的生命周期钩子，不是Vue的生命周期钩子**
Vue 2 自定义指令的生命周期钩子
在 **Vue 2.x** 中，自定义指令提供的钩子函数是下面这五个：

|钩子名称|触发时机|说明|
|---|---|---|
|**bind**|指令第一次绑定到元素时调用|可以在这里进行一次性初始化|
|**inserted**|元素插入父节点时调用（确保已进入 DOM）|可以操作真实 DOM|
|**update**|所在组件的 VNode 更新时调用（值可能变化，也可能没变）|每次数据更新都会触发|
|**componentUpdated**|所在组件的 VNode 及其子 VNode 全部更新后调用|组件完全更新后触发|
|**unbind**|指令与元素解绑时调用|做清理工作|
![[Pasted image 20251019144018.png]]

![[Pasted image 20251019144112.png]]
**总结**
![[Pasted image 20251019144151.png]]

## 指令v-loading的封装
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=63

### 下载axios
```npm
	npm install axios
```

### 用v-loading添加加载效果
![[Pasted image 20251019144730.png]]
![[Pasted image 20251019144945.png]]
![[Pasted image 20251019150725.png]]

### 总结
![[Pasted image 20251019150819.png]]


# 插槽
## 默认插槽
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=64
![[Pasted image 20251019151043.png]]
![[Pasted image 20251019151113.png]]
![[Pasted image 20251019151236.png]]
![[Pasted image 20251019151246.png]]![[Pasted image 20251019151301.png]]
**总结：**
![[Pasted image 20251019151340.png]]

## 后备内容--插槽的默认值
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=65
![[Pasted image 20251019152115.png]]
![[Pasted image 20251019152308.png]]
![[Pasted image 20251019152240.png]]
![[Pasted image 20251019152344.png]]

## 具名插槽--多处插槽自定义
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=66
![[Pasted image 20251019152433.png]]

![[Pasted image 20251019152457.png]]
![[Pasted image 20251019153749.png]]

**总结：**
![[Pasted image 20251019153840.png]]

## 作用域插槽
![[Pasted image 20251019154047.png]]
![[Pasted image 20251019154040.png]]![[Pasted image 20251019154712.png]]
**传出数据--以属性方式将数据打包成对象并传出**
![[Pasted image 20251019164537.png]]
**接收数据--#具名插槽="obj"**
![[Pasted image 20251019164841.png]]
![[Pasted image 20251019165048.png]]
![[Pasted image 20251019165206.png]]



# 单页应用程序--SPA
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=72
![[Pasted image 20251019184742.png]]
![[Pasted image 20251019185240.png]]![[Pasted image 20251019185307.png]]


# 路由
## 路由的介绍
![[Pasted image 20251019185351.png]]![[Pasted image 20251019185503.png]]
**不同的路径对应不同的组件**
![[Pasted image 20251019185523.png]]
![[Pasted image 20251019185555.png]]

## 路由的基本使用
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=73
### 介绍
![[Pasted image 20251019185655.png]]
![[Pasted image 20251019190036.png]]

### 引用
**安装路由--vue-router**
```npm
	npm install vue-router@3.6.5
```

![[Pasted image 20251019192131.png]]
![[Pasted image 20251019192540.png]]

## 配置路由规则和路由出口
![[Pasted image 20251019192701.png]]
**配置路由路径：**
![[Pasted image 20251019194356.png]]
**配置路由出口和组件的显示位置：**
![[Pasted image 20251019194455.png]]
![[Pasted image 20251019194651.png]]

## 路由组件的存放目录
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=74

![[Pasted image 20251019194735.png]]
**区分复用组件和页面组件：**
![[Pasted image 20251019194813.png]]
![[Pasted image 20251019194840.png]]
![[Pasted image 20251019195402.png]]

## 路由模块封装
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=76
![[Pasted image 20251020015722.png]]
	 1.将路由配置从main.js移动到router/index.js中
	 2.在index.js中重新导入vue
	 3.重新配置好导入的路由组件路径
	 4.导出路由配置
	 5.将配置好的index.js导入到main.js中
![[Pasted image 20251020021532.png]]
	@的意思是指绝对路径，这里指的是src
![[Pasted image 20251020021637.png]]
**总结**
![[Pasted image 20251020021717.png]]

## router-link的应用
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=77
![[Pasted image 20251020091511.png]]
![[Pasted image 20251020092708.png]]

## 高亮的两个类名--router-link-exact-active、router-link-active
![[Pasted image 20251020093042.png]]
**router-link-active：**
![[Pasted image 20251020093530.png]]
**router-link-exact-active：**
![[Pasted image 20251020093631.png]]
	写成a.router-link-active和.router-link-active都可以，**因为router-link会自动渲染成a标签**
	但是你会感觉用a.router-link-active会点击高亮得更快？这是为什么呢？
		`a.router-link-active` 的选择器**更具体**，优先级比 `.router-link-active` 高
		所以当两者都定义了样式时，`a.router-link-active` 的样式会“立即覆盖”掉前者，看起来像是“更快响应”。
**总结**
![[Pasted image 20251020093700.png]]

## 自定义匹配的类名
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=78
![[Pasted image 20251020093810.png]]
![[Pasted image 20251020093937.png]]
	**注意自定义类名要双引号**
![[Pasted image 20251020094027.png]]

## 导航的跳转传参
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=79
![[Pasted image 20251020095009.png]]

### 查询参数传参
![[Pasted image 20251020095136.png]]
	**传送方：** to="/xxx/?参数名=值"
	![[Pasted image 20251020100222.png]]
	**接收方：** $route.query.参数名
	![[Pasted image 20251020100246.png]]
	![[Pasted image 20251020100353.png]]
	![[Pasted image 20251020100258.png]]
	![[Pasted image 20251020100448.png]]

### 动态路由传参
![[Pasted image 20251020153329.png]]
	配置路由规则
	![[Pasted image 20251020160232.png]]
	**配置路由出口**
	![[Pasted image 20251020160440.png]]
	**接收参数**
	![[Pasted image 20251020160653.png]]
	![[Pasted image 20251020160824.png]]
	![[Pasted image 20251020160840.png]]

### 动态路由传参的可选符--/:words?
![[Pasted image 20251020161725.png]]

### 查询参数传参和动态路由传参的区别
![[Pasted image 20251020161313.png]]

## 路由重定向
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=80
![[Pasted image 20251020162245.png]]

## 路由找不到--404
![[Pasted image 20251020162647.png]]
![[Pasted image 20251020163237.png]]
![[Pasted image 20251020163321.png]]

## 路由模式设置
![[Pasted image 20251020164835.png]]
	默认的hash是基于a标签锚链接跳转实现的
	而history是基于HTML5的historyAPI实现的


## 点击按钮跳转
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=81
### path路径跳转--this.$router.push("路径名")
![[Pasted image 20251020165717.png]]
![[Pasted image 20251020165844.png]]

### name命名路由跳转--this.$router.push({ name:"路由名" })
![[Pasted image 20251020170026.png]]
![[Pasted image 20251020170202.png]]
![[Pasted image 20251020194529.png]]

### 路由返回--返回上一页
![[Pasted image 20251021185136.png]]

## 路由跳转的传参
![[Pasted image 20251020194810.png]]
![[Pasted image 20251020194916.png]]

### 由path直接传参
![[Pasted image 20251020222625.png]]

### 由path的query对象传参
![[Pasted image 20251020224032.png]]
	**接收参数：$route.query.key**

### 由动态路由直接传参
![[Pasted image 20251020224223.png]]
**或者**
![[Pasted image 20251020224905.png]]
**或者**
![[Pasted image 20251020225957.png]]
	 **接收参数：$route.params.words**
	 
![[Pasted image 20251020230257.png]]


## 路由缓存--keep alive
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=87
![[Pasted image 20251021185335.png]]
![[Pasted image 20251021185427.png]]

### 缓存的问题
**所有的组件都被缓存，以至于有些应该实时动态渲染的页面缓存了之前的信息**
![[Pasted image 20251021185607.png]]

### 缓存问题的解决--keep alive的三个属性include、exclude、max
![[Pasted image 20251021185905.png]]
	**exclude属性缓存的组件比较多的话，一般与max属性一起使用**

![[Pasted image 20251021190354.png]]


### 缓存的生命周期钩子--activated和deactivated
	active：组件可以被看见是
	deactived：组件被隐藏时

![[Pasted image 20251021190808.png]]
![[Pasted image 20251021191056.png]]
![[Pasted image 20251021191141.png]]


## 基于VueCli的自定义创建项目架子
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.videopod.episodes&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=88
**创建项目：**
![[Pasted image 20251022085325.png]]
![[Pasted image 20251022085340.png]]
![[Pasted image 20251022085410.png]]
	方向键选择，空格选中
![[Pasted image 20251022090216.png]]
![[Pasted image 20251022090519.png]]

## Eslint代码规范
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=89
### 代码规范的介绍
![[Pasted image 20251022091042.png]]
![[Pasted image 20251022091215.png]]

### Eslint规范报错--手动修正
![[Pasted image 20251022091632.png]]

### Eslint规范报错--自动修正
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=90
![[Pasted image 20251022091837.png]]
	在VSCode的设置中打开setting.json并粘贴配置代码


## vuex--状态管理工具
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=91
### vuex介绍
![[Pasted image 20251022093033.png]]

### vuex语法
#### 安装vuex插件，初始化一个仓库
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=93
![[Pasted image 20251022095205.png]]
	安装vuex插件
```npm
	// 安装vuex3插件
	npm install vuex@3
	// 或者
	npm install vuex@3 --legacy-peer-deps
```
	创建vuex模块文件store/index.js并新建仓库

![[Pasted image 20251022110249.png]]
	
	在main.js文件中导入store并挂载到Vue实例上
	
![[Pasted image 20251022100552.png]]
	
	验证
	
![[Pasted image 20251022110651.png]]

### vuex中的公共数据--state状态
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=94
**提供数据**
![[Pasted image 20251022110835.png]]

#### 在state中获取数据--方法一state：通过store直接访问
![[Pasted image 20251022111056.png]]
![[Pasted image 20251022112511.png]]


#### 在state中获取数据--方法二：通过辅助函数mapState将"this.$store.state.数据"自动映射到每个组件的compute中
![[Pasted image 20251022113558.png]]
![[Pasted image 20251022114018.png]]
	 这里mapState是封装了一个对象
```JavaScript
	{   count(){
			return this.$store.state.count
		},
		title(){
			return this.$store.state.title
		},
	}
```
	所有要用...展开对象，去除外面的{}，方便后续在computed中添加计算属性
	
![[Pasted image 20251022114757.png]]

### vuex中的公共方法--单向数据流的数据修改mutations
![[Pasted image 20251022115523.png]]
	![[Pasted image 20251022115639.png]]

#### mutations和this.$store.commit()传参
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=95
![[Pasted image 20251022120102.png]]
**传参**
![[Pasted image 20251022144644.png]]
	**注意：mutaions传递的参数叫做提交载荷，而且只能传递一个参数**
	![[Pasted image 20251022145341.png]]
	![[Pasted image 20251022145421.png]]
	![[Pasted image 20251022145432.png]]

#### 辅助函数mapMutation传参
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=96
![[Pasted image 20251022161500.png]]
![[Pasted image 20251022161409.png]]



### vuex中的异步处理--actions
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=97
#### actions和this.$store.dispatch()传参
![[Pasted image 20251022162005.png]]
![[Pasted image 20251022162322.png]]
**添加异步处理的actions**
![[Pasted image 20251022162447.png]]
**触发异步函数actions--this.$store.dispatch()**
![[Pasted image 20251022162644.png]]

#### 辅助函数mapActions
![[Pasted image 20251022164314.png]]

### vuex中的计算属性--getters
#### getters和$store.getters.getters的属性名
![[Pasted image 20251022165558.png]]
**定义getters**
![[Pasted image 20251022170549.png]]
**使用getters属性**
![[Pasted image 20251022170734.png]]


#### 辅助函数mapGetters
![[Pasted image 20251022172706.png]]

### vuex的模块moduel
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=98

#### moduel模块的基本使用
![[Pasted image 20251022203304.png]]![[Pasted image 20251022203423.png]]
##### 创建模块
![[Pasted image 20251022203542.png]]
##### 导入模块
![[Pasted image 20251022203803.png]]

#### 访问module模块的数据
https://www.bilibili.com/video/BV1HV4y1a7n4?spm_id_from=333.788.player.switch&vd_source=81f6abdfad38ec206b0ce368cd574c90&p=99
##### 访问module中state的数据
![[Pasted image 20251022205930.png]]
